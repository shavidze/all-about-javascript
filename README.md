# all-about-javascript

1. **Hoisting, var, let, const, functions** - როდესაც ჯს ენჯაინი მიიღებს კოდს გასაშვებად, პირველ რიგში მემორიში გამოყოფს ადგილს, რომ შეინახოს ფუნცქციები და ცვლადები. ფუნქციები, როგორც წესი ინახები რეფერენსებად და დარეგისტრირებული ფუნქციის value ყოველთვის არის <function>-ი. რაც შეეხება ცვლადებს,es6-ს ახალი ტიპები let და const-ის ცვლადები ინახება, როგორც <uninitialized> , ხოლო var-ი ინახება როგორც undefined.
  
  
2. **context(this)** - ყველა ფუნქციას გააჩნია კონტექსტი, რომელიც მიუთითებს იმ ობიექტს რომელსაც ეკუთხვნის ეს ფუნქცია. როგორც წესი ჩვეულებრივი ფუნქციია ეკუთვნის იმ კლასის ობიექტს, რომელმაც აღწერა ის, მაგრამ arrow -ფუნქციებში არ გვაქვს default context, თუმცა შეგვიძლია ხელით bind,call ან apply.

3. **lexical scope** - განსაზღვრავს როგორ არის შესაძლებელი წვდომა ჩადგმულ ფუნქციებში, მაგალითად ყოველი შიდა ფუნქციას აქვს წვდომა მის გარე ფუნქციებზე მაგრამ პირიქით არა.

4. **Event loop** - როგორც ვიცით ჯს არის 1 სრედიანი, მაგრამ ბრაუზერი გვაძლევს საშუალებას რომ გავაკეთოთ async ფუნქციები პარალელურად ისე, რომ არ დაიბლოკოს მეინ სრედი. ნებისმიერი ასინქრონული ოპერაცია ბრაუზერის web api-ში მიდის, იმის მერე რაც დამუშავდება ვარდება ივენთების Queue-ში და როდესაც მორჩება ქოლ სტეკი მაშინ დაიწყება Queue-ში არსებული შედეგების დაბრუნება იმ თანმიმდევრობით როგორც ჩადგნენ. Call-Stack -> Web-Api -> Queue -> Call-Stack.

5. **Closure** - ეს არის ფუნქციის Scope-ში არსებული ობიექტი, სადაც ინახება ამ ფუნქციის ზედა ფუნქციაში(ებში) არსებული ცვლადები. როდესაც დაგვჭირდება ისინი ჯერ ვნახავთ თუ არსებობენ ქლოჟერში თუ არადა ზემოთ დაიწყება ძებნა ინიციალიზაციისთვის.

6. **Async/Await** - არის ES6-ის Keywords. Async ფუნქცია ყოველთვის აბრუნებს Promise-ს.
                                                     
                                                     async function f() {
                                                              return 1;
                                                     }
                                                     f().then(alert); // 1
   ხოლო await ელოდება მანამ სანამ არ მოვა let x = promise;
  7. **Promise** - არის კლასი რომელიც ასინქრონულ ფუნქციის მნიშვნელობას აბრუნებს როგორც სინქრონული ტიპი და პასუხისმგებელია დაბრუნების შემდეგ შედეგის, resolve ან reject.
  
  8. **Lifecycle Hooks** - 1. ანგულარის ციკლი იწყება ngOnChanges თუ არ ჩავთვლით კონსტრუქტორს, რომელიც არ არის ჰუკი და იტვირთება კლასის შექმნის თანავე, რათა მოხდეს საჭირო ინტერფეისების დაინჯექტება. ngOnChange-უზრუნველჰყოფს კომპონენტის დააფდეითებას მას შემდეგ რაც შეიცვლება მშობლის დატა, ის გამოიძახება ყოველთვის როცა კომპონენტში შემომავალი @Input() შეიცვლება, თუ კომპონენტში საერთოდ არ გვაქვს @Input()  არასდროს არ გამოიძახება ngOnChange. 
                       2. ამის შემდეგ მოდის ngOnInit-ი, რომელიც ერთხელ როდესაც მოხდება კომპონენტის ინიციალიზაცია,მისი ჩატვირთვის დროს უკვე ყველა დატა და პროპერტი დასეტილია. 
                       3. ამის შემდგომ მოდის ngDoCheck რომელიც იძახება ყველა ჩეინჯზე, ის ეშვება ყოველთვის ngOnChanges-გან განსხვავებით. მაგალითად თუ მე რაიმე შვილი კომპონენტი გადავიყვანე ChangeDetectionStrategy.OnPush-ზე, ანუ გავუთიშე default change detection, ანგულარი როგორ იქცევა - უყურებს მშობლის დატა, კერძოდ,თუ მშობლიდან მოწოდებული @Input() დატის რეფერენსი შეიცვლება, მაშინ დაიჭერს ამ ცვლილებას და გაეშვება ngOnChange-ი თუ არ შეიცვალა რეფერენსი - არ გაეშვება, ხოლო ngDoCheck-ი ყველაფრის და მიუხედევას დაიქოლება. ამიტომ, როდესაც ვთიშავთ ანგულარის default change detection-ს, რჩევა იქნება ის, რომ ვწეროთ immutable.js -თ, სადაც არ არსებობს mutable ობიექტები.
                       4. შემდეგ მოდის ngAfterContentInit, რომელიც ეშვება ერთადერთხელ როდესაც ყველა კონტენტი ჩაიტვირთება ამ კომპონენტის.  
                       5. ngAfterContentChecked - პირველად გამოიძახება ngAfterContentInit-ის მერე, მაგრამ ამის მერე ყოველი მცირე ჩეინჯზე ngDoCheck-ის მერე დაიქოლება.
                       6. ngAfterViewInit - დაიქოლება ერთადერთხელ, როცა წარმატებით ჩაიტვირთა ყველა შვილი კომპონენტი ngAfterContentChecked ამის შემდეგ.
                       7. ngAfterViewChecked - პირველად გამოიძახება ngAfterViewInit-ის მერე, მაგრამ ამის მერე ყოველ მცირე ჩეინჯზე ngDoCheck-ის მერე რიგში მოყვება ngAfterContentChecked-ს.
                       8. ngOnDestroy - გამოიძახება როდესაც კომპონენტი საჭიროებს წაშლას, მაგალითად კლიკზე გვინდა რომ გამოჩნდეს და გაქრეს კომპონენტი, როდესაც ვაქრობთ გამოიძახება ngOnDestroy.
  
  9. ** Angular Compiler** 
                                                      
                                                      
  
