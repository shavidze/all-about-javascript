# all-about-javascript

1. Hoisting, var, let, const, functions - როდესაც ჯს ენჯაინი მიიღებს კოდს გასაშვებად, პირველ რიგში მემორიში გამოყოფს ადგილს, რომ შეინახოს ფუნცქციები და ცვლადები. ფუნქციები, როგორც წესი ინახები რეფერენსებად და დარეგისტრირებული ფუნქციის value ყოველთვის არის <function>-ი. რაც შეეხება ცვლადებს,es6-ს ახალი ტიპები let და const-ის ცვლადები ინახება, როგორც <uninitialized> , ხოლო var-ი ინახება როგორც undefined.
  
  
2. context(this) - ყველა ფუნქციას გააჩნია კონტექსტი, რომელიც მიუთითებს იმ ობიექტს რომელსაც ეკუთხვნის ეს ფუნქცია. როგორც წესი ჩვეულებრივი ფუნქციია ეკუთვნის იმ კლასის ობიექტს, რომელმაც აღწერა ის, მაგრამ arrow -ფუნქციებში არ გვაქვს default context, თუმცა შეგვიძლია ხელით bind,call ან apply.

3. lexical scope - განსაზღვრავს როგორ არის შესაძლებელი წვდომა ჩადგმულ ფუნქციებში, მაგალითად ყოველი შიდა ფუნქციას აქვს წვდომა მის გარე ფუნქციებზე მაგრამ პირიქით არა.

4. Event loop - როგორც ვიცით ჯს არის 1 სრედიანი, მაგრამ ბრაუზერი გვაძლევს საშუალებას რომ გავაკეთოთ async ფუნქციები პარალელურად ისე, რომ არ დაიბლოკოს მეინ სრედი. ნებისმიერი ასინქრონული ოპერაცია ბრაუზერის web api-ში მიდის, იმის მერე რაც დამუშავდება ვარდება ივენთების Queue-ში და როდესაც მორჩება ქოლ სტეკი მაშინ დაიწყება Queue-ში არსებული შედეგების დაბრუნება იმ თანმიმდევრობით როგორც ჩადგნენ. Call-Stack -> Web-Api -> Queue -> Call-Stack.

5. Closure - ეს არის ფუნქციის Scope-ში არსებული ობიექტი, სადაც ინახება ამ ფუნქციის ზედა ფუნქციაში(ებში) არსებული ცვლადები. როდესაც დაგვჭირდება ისინი ჯერ ვნახავთ თუ არსებობენ ქლოჟერში თუ არადა ზემოთ დაიწყება ძებნა ინიციალიზაციისთვის.

6. Async/Await - არის ES6-ის Keywords. ასინქ ფუნქცია ყოველთვის აბრუნებს Promise-ს. 
                                                     async function f() {
                                                              return 1;
                                                     }

                                                      f().then(alert); // 1
                                                      
  7. Promise - არის კლასი რომელიც ასინქრონულ ფუნქციის მნიშვნელობას აბრუნებს როგორც სინქრონული ტიპი და პასუხისმგებელია დაბრუნების შემდეგ შედეგის, resolve ან reject.
  
  8.
                                                      
                                                      
                                                      
  
